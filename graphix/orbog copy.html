<!DOCTYPE html>
<html>
<head>
    <title>GLSL Shader Demo with Labeled User Orbs</title>
    <style>

        @font-face {
            font-family: 'ag5';
            src: url('./AG5.ttf') format('truetype');
        }

        @font-face {
            font-family: 'frutiger';
            src: url('./Frutiger.ttf') format('truetype');
        }

        @font-face {
            font-family: 'cute';
            src: url('./CutieTopRegular-VArx.ttf') format('truetype');
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: absolute;
        }
        body {
            margin: 0;
            overflow: hidden;
            background: black;
            font-family: 'ag5';
        }
        #labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .label {
            position: absolute;
            transform: translate(-50%, -100%);
            color: white;
            font-family: 'times new roman';
            font-size: 14px;
            text-shadow: 0 0 3px black, 0 0 3px black, 0 0 3px black;
            white-space: nowrap;
            transition: opacity 0.3s;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
        }
        .label::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            width: 1px;
            height: 15px;
            background: white;
            box-shadow: 0 0 3px black;
        }
        #streamInfo {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgb(133, 133, 133);
            font-family: 'times new roman';
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .live-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            /* background: rgba(0, 0, 0, 0.7); */
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        .live-dot {
            width: 8px;
            height: 8px;
            background: #ff0000;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .live-dot.no-animation {
            animation: none;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }
        .stream-time, #date {
            /* background: rgba(0, 0, 0, 0.7); */
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .stream-time {
            font-family: 'cute';
        }
        .now-playing {
            /* background: rgba(0, 0, 0, 0.7); */
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        #playOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
            cursor: pointer;
            z-index: 1001;
            font-family: 'times new roman';
            overflow: hidden;
        }
        
        #overlayLeft, #overlayRight {
            position: absolute;
            top: 0;
            height: 50%;
            width: 100%;
            background: url('./gmbg.gif');
            transition: transform 2.4s ease-in .5s;
        }
        
        #overlayLeft {
            top: 0;
        }
        
        #overlayRight {
            top: 50%;
        }
        
        #playOverlay.hidden #overlayLeft {
            transform: translateY(-100%);
        }
        
        #playOverlay.hidden #overlayRight {
            transform: translateY(100%);
        }
        
        #playOverlay.hidden #passwordForm {
            opacity: 0;
        }

        #cubeStage {
            /* width: 400px; */
            /* filter: brightness(0.5); */

        }
        #passwordForm {
            background: rgb(0, 0, 0);
            padding: 30px;
            backdrop-filter: blur(5px);
            text-align: center;
            border: 4px ridge gray;
            z-index: 10;
            position: relative;
            transition: opacity 0.5s ease;
        }

        #passwordForm.animate {
            animation: blink .5s forwards;
            animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        @keyframes blink {
            0% {transform: scaleY(1) scaleX(1);}
            30% {transform: scaleY(0.01) scaleX(1); filter: blur(10px) brightness(10.5);}
            100% {transform: scaleY(0) scaleX(0);
            filter: blur(10px) brightness(10.5);}
        }

        #enterButton {
            border-radius: 0;
            /* color: #fff; */
            padding: 10px 20px;
            font-family: 'ag5', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #enterButton:hover {
            background: rgba(255,255,255,0.3);
        }
        #passwordMessage {
            margin-top: 20px;
            font-size: 14px;
            opacity: 0.7;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        #playOverlay p {
            font-family: 'cute';
            font-size: 18px;
            margin: 0;
            text-align: center;
        }

        /* Add particles for playful effect during transition */
        .audio-particle {
            display: none;
        }

        /* Remove the ripple animation */
        @keyframes ripple {
            0% { transform: scale(1); filter: none; }
            100% { transform: scale(1); filter: none; }
        }

        .canvas-ripple {
            animation: none;
        }

        #playOverlay.hidden #passwordForm {
            opacity: 0;
        }

        .old-hr {
            width: 100%;
            height: 1px;
            background: rgb(0, 0, 0);
            border-top: 1px solid rgb(55, 55, 55);
            margin: 10px 0;
        }

        .event-time {
            font-size: 18px;
            margin: 0;
            text-align: center;
            color: red;
            animation: concert 1.5s infinite alternate ease-in-out;
        }

        @keyframes concert {
            0% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <div id="playOverlay">
        <div id="overlayLeft"></div>
        <div id="overlayRight"></div>
        <div id="passwordForm">
            <img width="120" style="margin-top: -10px;" id="cubeStage" width="" src="./cubestage3.png" alt="Cube Stage">
            
            <!-- Old-school text marquee effect -->
            <!-- <marquee behavior="alternate" scrollamount="3">
                <font color="#ffff00">★</font> Live <font color="#ffff00">★</font>
            </marquee> -->
            
            <h1 style="margin-top: 0;">The Tandy Cube</h1>
            
            <div class="event-status">
                <!-- <div class="status-badge">
                    <span class="live-indicator"><span class="live-dot no-animation"></span> STREAMING NOW</span>
                </div> -->
                <div class="event-time">Concert in progress</div>
            </div>
            
            <div class="old-hr"></div>
            
            <div class="event-artist">Kat Mazur</div>
            <div class="event-title">Dancing to: <i>Cut on a Can</i></div>
            
<br>
            
            <button id="enterButton">Enter</button>
 
            
            <div id="passwordMessage"></div>
        </div>
    </div>
    <canvas id="glCanvas"></canvas>
    <div id="streamInfo">
        <div class="live-indicator">
            <div class="live-dot"></div>
            <span>LIVE</span>
        </div>
        <div class="stream-time">00:00:00</div>
        <div id="date"></div>
        <div class="now-playing marquee">Cut on a Can dance – Kat Mazur</div>
    </div>
    <img id="displacementMap" src="./displace.png" 
         style="display: none;" crossorigin="anonymous">
         <video id="videoTexture" style="display: none;" loop playsinline>
            <source src="./trans2.webm" type="video/webm">
         </video>
    <script id="vertexShader" type="x-shader/x-vertex">
        precision mediump float;
        attribute vec4 aVertexPosition;
        varying vec2 vTextureCoord;
        
        void main() {
            vTextureCoord = (aVertexPosition.xy + 1.0) / 2.0;
            gl_Position = aVertexPosition;
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        
        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec2 iMouse;
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        uniform vec3 uOrbPositions[10];  // Max 10 orbs
        uniform vec3 uOrbColors[10];     // Color for each orb
        uniform int uOrbCount;           // Current number of active orbs
        uniform sampler2D uTextTexture;  // Single text texture (we'll use texture atlas later)
        uniform vec3 uTextPositions[10]; // Positions for text billboards
        uniform int uTextCount;          // Number of active text billboards
        uniform vec3 uCameraOffset;      // Camera position offset for WASD movement
        varying vec2 vTextureCoord;

        #define EPSILON .0001
        #define MAX_VIEW_STEPS 100
        #define MAX_SHADOW_STEPS 64
        #define OCCLUSION_SAMPLES 8.0
        #define OCCLUSION_FACTOR .5
        #define MAX_DEPTH 10.0
        #define BUMP_FACTOR .03
        #define TEX_SCALE_FACTOR .4
        #define ORB_RADIUS 0.2
        #define TEXT_BILLBOARD_SIZE vec2(0.3, 0.1) // Width and height of text billboards

        #define BOX_POS vec3(0.0, 0.0, 0.0)
        #define BOX_DIM vec3(1.0, 1.0, 1.0)
        #define LIGHT_COLOR vec4(1.0)
        #define PEN_FACTOR 50.0
        #define MAT_COLOR vec4(1.0)
        #define MAT_GLOSS 1.0
        #define PLANE_SIZE vec2(.5 * (16./9.), .5)
        #define PLANE_CENTER vec3(0.0, 1.12, 0.0)

        struct Light {
            vec3 position;
            vec4 color;
            float brightness;
            float penumbraFactor;
        };

        struct Material {
            vec4 color;
            float gloss;
        };

        float distSphere(vec3 p, vec3 center, float radius) {
            return length(p - center) - radius;
        }

        vec4 tex3D(in vec3 p, in vec3 n, sampler2D tex) {
            vec4 x = texture2D(tex, p.yz);
            vec4 y = texture2D(tex, p.xz);
            vec4 z = texture2D(tex, p.xy);
            return x * abs(n.x) + y * abs(n.y) + z * abs(n.z);
        }

        float sdBoxFrame( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

float distVideoPlane(vec3 p) {
    // Plane facing camera, centered at (0, 0, 0), size 2x2 in X and Y, lying at Z = 0.5
    // Adjust position/size as needed
    vec3 center = PLANE_CENTER;
    vec2 planeSize = PLANE_SIZE; // half extents
    vec3 local = p - center;

    // Only render front-facing side (optional)
    if (abs(local.x) > planeSize.x || abs(local.y) > planeSize.y) return 100.0;

    return abs(local.z); // distance to z-plane
}

        float distTextBillboard(vec3 p, vec3 center, vec3 cameraPos) {
            // Calculate billboard orientation (always face camera)
            vec3 toCam = normalize(cameraPos - center);
            vec3 up = vec3(0.0, 1.0, 0.0);
            vec3 right = normalize(cross(up, toCam));
            up = cross(toCam, right);
            
            // Transform point to billboard local space
            vec3 local = p - center;
            vec2 localPos = vec2(dot(local, right), dot(local, up));
            
            // Check if within billboard bounds
            if (abs(localPos.x) > TEXT_BILLBOARD_SIZE.x || abs(localPos.y) > TEXT_BILLBOARD_SIZE.y) {
                return 100.0;
            }
            
            // Calculate UV and sample texture to check if there's text here
            vec2 uv = (localPos / TEXT_BILLBOARD_SIZE) * 0.5 + 0.5;
            uv.y = 1.0 - uv.y;
            uv.x = 1.0 - uv.x;
            
            vec4 textColor = texture2D(uTextTexture, uv);
            
            // Only register as a surface if there's text (alpha > threshold)
            if (textColor.a < 0.1) {
                return 100.0; // No surface where text is transparent
            }
            
            // Distance to billboard plane
            return abs(dot(local, toCam));
        }

        float distBox(vec3 samplePos, vec3 boxPos, vec3 boxDim) {    
            vec3 normal = normalize(samplePos - boxPos);
            float bump = 0.0;
            
            if(length(samplePos-boxPos) < length(boxDim)) {
                vec4 tex = tex3D(samplePos * TEX_SCALE_FACTOR, normal, iChannel0);
                bump = tex.x * BUMP_FACTOR;  // Using .x instead of .r
            }
            
            vec3 d = abs(samplePos-boxPos) - boxDim;
            return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) + bump;
        }
        float sdBox(vec3 samplePos, vec3 boxPos, vec3 boxDim) {    
            vec3 normal = normalize(samplePos - boxPos);
            float bump = 0.0;
            
            
            vec3 d = abs(samplePos-boxPos) - boxDim;
            return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
        }
        

        float sdPlane( vec3 p, vec3 n, float h )
{
  // n must be normalized
  return dot(p,n) + h;
}

float getDist(vec3 samplePos, bool skipVideoPlane, vec3 cameraPos) {
    float d = min(distBox(samplePos, BOX_POS, BOX_DIM), 
    distBox(samplePos, vec3(0.0, -5.0, 0.0), vec3(4.0, 4.0, 4.0)));
    //float d =     distBox(samplePos, vec3(0.0, -5.0, 0.0), vec3(4.0, 4.0, 4.0));
    //float d2 = sdBox(samplePos, vec3(0.0, 1.0, 0.0), vec3(0.001,.4, 0.4));
    //d = min(d, d2);

    // Check orbs
    for (int i = 0; i < 10; i++) {
        if (i >= uOrbCount) break;
        d = min(d, distSphere(samplePos, uOrbPositions[i], ORB_RADIUS));
    }

    // Check text billboards
    for (int i = 0; i < 10; i++) {
        if (i >= uTextCount) break;
        d = min(d, distTextBillboard(samplePos, uTextPositions[i], cameraPos));
    }

    // Add video plane
    if (!skipVideoPlane) {
    float dVideo = distVideoPlane(samplePos);
    d = min(d, dVideo);
    }

    return d;
}

        void camPolar(out vec3 pos, out vec3 dir, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord) {
            vec2 c = cos(rotation);
            vec4 s;
            s.xy = sin(rotation);
            s.zw = -s.xy;
            
            dir.xy = fragCoord.xy - iResolution.xy*.5;
            dir.z = iResolution.y*zoom;
            dir = normalize(dir);
            
            dir.yz = dir.yz*c.x + dir.zy*s.zx;
            dir.xz = dir.xz*c.y + dir.zx*s.yw;
            
            pos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);
        }

        void marchThroughField(inout vec3 pos, vec3 dir, vec3 eye, bool skipVideoPlane) {
            float dist;
            for(int i = 0; i < MAX_VIEW_STEPS; i++) {
                dist = getDist(pos, skipVideoPlane, eye);
                if(dist < EPSILON || length(pos-eye) > MAX_DEPTH-EPSILON)            
                    return;
                pos += dir * dist;
            }
        }

        vec3 getNormal(vec3 pos) {
            float d = getDist(pos, false, vec3(0.0));
            return normalize(vec3(
                getDist(pos+vec3(EPSILON,0,0), false, vec3(0.0))-d,
                getDist(pos+vec3(0,EPSILON,0), false, vec3(0.0))-d,
                getDist(pos+vec3(0,0,EPSILON), false, vec3(0.0))-d
            ));
        }

        float calcOcclusion(vec3 pos, vec3 surfaceNormal) {
            float result = 0.0;
            vec3 normalPos = vec3(pos);
            for(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0) {
                normalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);
                result += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-getDist(normalPos, false, vec3(0.0));
            }
            return 1.0-(OCCLUSION_FACTOR*result);
        }

        float calcShadow(vec3 origin, vec3 lightDir, Light light) {
            float dist;
            float result = 1.0;
            float lightDist = length(light.position - origin);
            
            vec3 pos = origin + lightDir * (EPSILON * 15.0 + BUMP_FACTOR);
        
            for (int i = 0; i < MAX_SHADOW_STEPS; i++) {
                // Check regular geometry (excluding video plane and text billboards)
                dist = getDist(pos, true, vec3(0.0));
                
                // Manually check only non-text geometry for shadows
                float d = min(distBox(pos, BOX_POS, BOX_DIM), 
                distBox(pos, vec3(0.0, -5.0, 0.0), vec3(4.0, 4.0, 4.0)));
                
                // Check orbs for shadows
                for (int j = 0; j < 10; j++) {
                    if (j >= uOrbCount) break;
                    d = min(d, distSphere(pos, uOrbPositions[j], ORB_RADIUS));
                }
                
                dist = d;
        
                // Check video plane
                vec3 center = PLANE_CENTER;
                vec2 planeSize = PLANE_SIZE;
                vec3 local = pos - center;
        
                // Ray-plane intersection (plane at Z = center.z)
                if (abs(lightDir.z) > 0.0001) {  // avoid division by 0
                    float tPlane = (center.z - origin.z) / lightDir.z;
                
                    if (tPlane > 0.0 && tPlane < lightDist) {
                        vec3 hitPos = origin + tPlane * lightDir;
                        vec3 local = hitPos - center;
                
                        if (abs(local.x) <= planeSize.x && abs(local.y) <= planeSize.y) {
                            vec2 uv = local.xy / planeSize + 0.5;
                            uv.y = 1.0 - uv.y;
                            vec4 tex = texture2D(iChannel1, uv);
                
                            if (tex.a >= 0.2) {
                                return 0.0; // opaque part of the video plane blocks light
                            }
                        }
                    }
                }
        
                if (dist < EPSILON) {
                    return 0.0; // Hit solid geometry
                }
        
                if (length(pos - origin) > lightDist || length(pos - origin) > MAX_DEPTH) {
                    return result;
                }
        
                pos += lightDir * dist;
        
                if (length(pos - origin) < lightDist) {
                    result = min(result, light.penumbraFactor * dist / length(pos - origin));
                }
            }
            return result;
        }
        

        vec4 calcLighting(vec3 samplePos, vec3 eye, Light light, Material material) {
            float lightDist = length(light.position-samplePos);
            vec3 lightDir = normalize(light.position-samplePos);
            vec3 eyeDir = normalize(samplePos-eye);
            vec3 surfaceNormal = getNormal(samplePos);
            vec3 reflection = normalize(reflect(eyeDir, surfaceNormal));
            
            float specular = pow(max(0.0, dot(lightDir, reflection)), 72.0);
            float diffuse = max(0.0, dot(lightDir, surfaceNormal));
            float ambient = .05;
            
            float attenuation = min(1.0, 1.0/(lightDist/light.brightness));
            float shadow = calcShadow(samplePos, lightDir, light);
            float occlusion = calcOcclusion(samplePos, surfaceNormal);
            
            // Check if we're on an orb surface
            vec4 finalColor = material.color;
            for(int i = 0; i < 10; i++) {
                if(i >= uOrbCount) break;
                if(length(samplePos - uOrbPositions[i]) < ORB_RADIUS + EPSILON) {
                    finalColor = vec4(uOrbColors[i], 1.0);
                    break;
                }
            }
            
            return light.color * finalColor * clamp(((specular+diffuse)*shadow*attenuation)+(ambient*occlusion), 0.0, 1.0);
        }

        vec4 shade(vec3 pos, vec3 dir, vec3 eye, Light light, Material material) {
            if (length(pos - eye) > MAX_DEPTH - EPSILON) return vec4(0.0);

            // Check if this point is on a text billboard
            for (int i = 0; i < 10; i++) {
                if (i >= uTextCount) break;
                
                vec3 center = uTextPositions[i];
                vec3 toCam = normalize(eye - center);
                vec3 up = vec3(0.0, 1.0, 0.0);
                vec3 right = normalize(cross(up, toCam));
                up = cross(toCam, right);
                
                vec3 local = pos - center;
                vec2 localPos = vec2(dot(local, right), dot(local, up));
                
                if (abs(localPos.x) <= TEXT_BILLBOARD_SIZE.x && 
                    abs(localPos.y) <= TEXT_BILLBOARD_SIZE.y &&
                    abs(dot(local, toCam)) < EPSILON) {
                    
                    // Calculate UV coordinates for the text texture
                    vec2 uv = (localPos / TEXT_BILLBOARD_SIZE) * 0.5 + 0.5;
                    uv.y = 1.0 - uv.y; // Flip Y coordinate
                    uv.x = 1.0 - uv.x; // Flip X coordinate if needed
                    
                    // Sample the text texture
                    vec4 textColor = texture2D(uTextTexture, uv);
                    
                    // Only render the text, no background
                    if (textColor.a > 0.1) {
                        return textColor;
                    }
                }
            }

            // Determine if this point is on the video plane
            vec3 center = PLANE_CENTER;
            vec2 planeSize = PLANE_SIZE;
            vec3 local = pos - center;
        
            if (abs(local.z) < EPSILON &&
            abs(local.x) <= planeSize.x &&
            abs(local.y) <= planeSize.y) {
        
                vec2 uv = local.xy / planeSize + 0.5;
                uv.y = 1.0 - uv.y;
        
                vec4 tex = texture2D(iChannel1, uv);
                
                // Calculate lighting for both front and back of the video plane
                float lightDist = length(light.position - pos);
                vec3 lightDir = normalize(light.position - pos);
                vec3 eyeDir = normalize(pos - eye);
                
                // Calculate lighting for front face
                vec3 frontNormal = vec3(0.0, 0.0, 1.0);
                vec3 frontReflection = normalize(reflect(eyeDir, frontNormal));
                float frontSpecular = pow(max(0.0, dot(lightDir, frontReflection)), 72.0);
                float frontDiffuse = max(0.0, dot(lightDir, frontNormal));
                
                // Calculate lighting for back face
                vec3 backNormal = vec3(0.0, 0.0, -1.0);
                vec3 backReflection = normalize(reflect(eyeDir, backNormal));
                float backSpecular = pow(max(0.0, dot(lightDir, backReflection)), 72.0);
                float backDiffuse = max(0.0, dot(lightDir, backNormal));
                
                // Use the stronger of front or back lighting
                float specular = max(frontSpecular, backSpecular);
                float diffuse = max(frontDiffuse, backDiffuse);
                float ambient = 0.3; // Increased from 0.05 to maintain higher minimum brightness
                
                float attenuation = min(1.0, 1.0/(lightDist/light.brightness));
                float shadow = calcShadow(pos, lightDir, light);
                float occlusion = calcOcclusion(pos, frontNormal); // Using front normal for occlusion
                
                // Apply lighting to the video texture with higher minimum brightness
                vec4 litColor = light.color * tex * clamp(((specular+diffuse)*shadow*attenuation*0.7)+(ambient*occlusion), 0.4, 1.0);
                
                // Raymarch through if video is partially transparent
                vec3 deepPos = pos;
                marchThroughField(deepPos, dir, eye, true);
                
                // Only blend if something was hit
                if (length(deepPos - eye) < MAX_DEPTH - EPSILON) {
                    vec4 background = calcLighting(deepPos, eye, light, material);
                    return mix(background, litColor, tex.a);
                }
                
                return litColor;
            }
        
            return calcLighting(pos, eye, light, material);
        }

        void main() {
            vec2 fragCoord = gl_FragCoord.xy;
            vec3 pos, dir, eye;
            
            camPolar(pos, dir, vec3(0.0), vec2(.5, iMouse.x*.0075+.025), 3.75, 1.0, fragCoord);
            eye = vec3(pos);
            
            Light light = Light(
                vec3(3.0*sin(iTime+1.3), 3.5, 3.0*cos(iTime+1.3)),
                LIGHT_COLOR,
                3.0,
                PEN_FACTOR
            );
            Material mat = Material(MAT_COLOR, MAT_GLOSS);
            
            marchThroughField(pos, dir, eye, false);
            
            gl_FragColor = shade(pos, dir, eye, light, mat);
        }
    </script>
    <script>
        let gl;
        let program;
        let mouseX = 0;
        let startTime;
        let videoTexture;
        let streamStartTime;
        let videoStarted = false;
        let audioFadeInterval;
        let audioContext;

        // Camera movement variables
        let cameraPosition = { x: 0, y: 0, z: 0 };
        let keys = { w: false, a: false, s: false, d: false, q: false, e: false };
        const moveSpeed = 0.05;

        const date = document.getElementById('date');
        date.innerHTML = new Date().toLocaleDateString();

        const video = document.getElementById('videoTexture');
        const playOverlay = document.getElementById('playOverlay');
        const passwordInput = document.getElementById('passwordInput');
        const enterButton = document.getElementById('enterButton');
        const passwordMessage = document.getElementById('passwordMessage');
        const CORRECT_PASSWORD = 'orbspace2024';

        function setupAudioContext() {
            // Create audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create media element source from video
            const source = audioContext.createMediaElementSource(video);
            
            // Create gain node for volume control
            const gainNode = audioContext.createGain();
            
            // Start with volume at 0
            gainNode.gain.value = 0;
            
            // Create analyzer node for visualizations (keep for future use but don't use it now)
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            
            // Connect nodes: source -> gain -> analyser -> destination
            source.connect(gainNode);
            gainNode.connect(analyser);
            analyser.connect(audioContext.destination);
            
            return { gainNode, analyser };
        }

        function fadeInAudio(audioNodes, duration = 3000) {
            const { gainNode } = audioNodes;
            
            // Cancel any existing fade
            if (audioFadeInterval) clearInterval(audioFadeInterval);
            
            const startTime = Date.now();
            const initialVolume = gainNode.gain.value;
            const targetVolume = 1.0;
            
            audioFadeInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease-in function for smoother fade
                const easedProgress = progress * progress;
                
                // Set new volume
                gainNode.gain.value = initialVolume + (targetVolume - initialVolume) * easedProgress;
                
                // If we're done, clear the interval
                if (progress >= 1) {
                    clearInterval(audioFadeInterval);
                    audioFadeInterval = null;
                }
            }, 16); // Update roughly 60 times per second
        }

        function startVideo() {
            if (!videoStarted) {
                // Resume audio context if suspended (browser policy)
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                video.play().then(() => {
                    videoStarted = true;
                    playOverlay.classList.add('hidden');
                    
                    // Set up audio context and fade in the audio
                    const audioNodes = setupAudioContext();
                    
                    // Wait for animation to reach halfway point before starting audio fade
                    setTimeout(() => {
                        fadeInAudio(audioNodes);
                    }, 1200); // Half of the 2.4s transition
                    
                }).catch(error => {
                    console.warn('Video playback failed:', error);
                });
            }
        }

        enterButton.addEventListener('click', () => {
            playOverlay.classList.add('hidden');
            passwordForm.classList.add('animate');
            startVideo();
        });

        // Orb management
        const MAX_ORBS = 10;
        const ORB_LIFETIME = 10000; // 10 seconds lifetime for each orb
        const SPAWN_INTERVAL = 2000; // 2 seconds between spawns
        let orbs = [];

        const RANDOM_NAMES = [
            "umru", "ryjelsum", "qui.et", "lost_in_the_loop", "npnc", "theresa_sweetheart", "edude92", "tristan", "Crenchwater", "erowidfan", "ButitsAlex"
        ];

        function getRandomName() {
            return RANDOM_NAMES[Math.floor(Math.random() * RANDOM_NAMES.length)];
        }

        class Orb {
    constructor(name) {
        this.name = name;
        this.position = this.getValidPosition();
        this.color = [
            Math.random() * 0.5 + 0.5, // Brighter colors (0.5 - 1.0)
            Math.random() * 0.5 + 0.5,
            Math.random() * 0.5 + 0.5
        ];
        this.createdAt = Date.now();
        this.textTexture = this.createTextTexture();
        this.textPosition = [
            this.position[0],
            this.position[1] + 0.3, // Reduced from 0.4 to bring text closer to orb
            this.position[2]
        ];
    }

    getValidPosition() {
        const angle = Math.random() * Math.PI * 2;
        const radius = 2 + Math.random() * 0.5; // 2-2.5 units from center
        const height = Math.random() * 1.2 - 0.6; // -0.6 to 0.6 vertical range
        
        return [
            Math.cos(angle) * radius,
            height,
            Math.sin(angle) * radius
        ];
    }

    createTextTexture() {
        // Create a canvas to render text
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 256;
        canvas.height = 64;
        
        // Clear canvas with transparent background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set text properties
        ctx.font = '24px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Add text shadow for better visibility
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        // Draw the text
        ctx.fillText(this.name, canvas.width / 2, canvas.height / 2);
        
        // Create WebGL texture from canvas
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        
        return texture;
    }

    removeLabel() {
        // Clean up WebGL texture
        if (this.textTexture) {
            gl.deleteTexture(this.textTexture);
        }
    }

    updateLabelPosition() {
        // No longer needed since we're using 3D billboards
    }
}


        function loadTexture(gl) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            const pixel = new Uint8Array([127, 127, 127, 255]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

            const image = document.getElementById('displacementMap');
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            };
            
            image.src = 'https://picsum.photos/256/256';
            
            return texture;
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            const positions = new Float32Array([
                -1.0, -1.0,
                1.0, -1.0,
                -1.0, 1.0,
                1.0, 1.0,
            ]);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            return positionBuffer;
        }

        function initGL() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
            
            streamStartTime = Date.now();
            
            if (!gl) {
                alert('WebGL not supported');
                return;
            }

            try {
                const vertexShaderSource = document.querySelector('#vertexShader').textContent;
                const fragmentShaderSource = document.querySelector('#fragmentShader').textContent;

                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

                program = gl.createProgram();
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(`Program link error: ${gl.getProgramInfoLog(program)}`);
                }

                gl.useProgram(program);

                // Set up position attribute
                const positionBuffer = initBuffers(gl);
                const positionLocation = gl.getAttribLocation(program, 'aVertexPosition');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                // Initialize displacement texture
                const texture = loadTexture(gl);
                const texLocation = gl.getUniformLocation(program, 'iChannel0');
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(texLocation, 0);

                // video texture
                const videoUniformLocation = gl.getUniformLocation(program, 'iChannel1');
                gl.uniform1i(videoUniformLocation, 1); // Tell GLSL: "use texture unit 1"

                // Initialize video texture
                videoTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, videoTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                startTime = Date.now();
                
                // Start orb management
                manageOrbs();
                
                requestAnimationFrame(render);
            } catch (error) {
                console.error('Error during initialization:', error);
                alert('Shader error: ' + error.message);
            }
        }

        function manageOrbs() {
            const now = Date.now();
            
            orbs = orbs.filter(orb => {
                const alive = (now - orb.createdAt) < ORB_LIFETIME;
                if (!alive) {
                    orb.removeLabel();
                }
                return alive;
            });

            if (orbs.length < MAX_ORBS) {
                orbs.push(new Orb(getRandomName()));
            }

            setTimeout(manageOrbs, SPAWN_INTERVAL);
        }

        function resizeCanvas() {
            const canvas = gl.canvas;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
        }

        function updateOrbUniforms() {
            const orbPositionsLoc = gl.getUniformLocation(program, 'uOrbPositions');
            const orbColorsLoc = gl.getUniformLocation(program, 'uOrbColors');
            const orbCountLoc = gl.getUniformLocation(program, 'uOrbCount');

            const positions = new Float32Array(MAX_ORBS * 3);
            const colors = new Float32Array(MAX_ORBS * 3);

            orbs.forEach((orb, index) => {
                positions[index * 3] = orb.position[0];
                positions[index * 3 + 1] = orb.position[1];
                positions[index * 3 + 2] = orb.position[2];

                colors[index * 3] = orb.color[0];
                colors[index * 3 + 1] = orb.color[1];
                colors[index * 3 + 2] = orb.color[2];
            });

            gl.uniform3fv(orbPositionsLoc, positions);
            gl.uniform3fv(orbColorsLoc, colors);
            gl.uniform1i(orbCountLoc, orbs.length);
        }

        function updateTextUniforms() {
            const textPositionsLoc = gl.getUniformLocation(program, 'uTextPositions');
            const textCountLoc = gl.getUniformLocation(program, 'uTextCount');
            const textTextureLoc = gl.getUniformLocation(program, 'uTextTexture');

            const positions = new Float32Array(MAX_ORBS * 3);

            orbs.forEach((orb, index) => {
                positions[index * 3] = orb.textPosition[0];
                positions[index * 3 + 1] = orb.textPosition[1];
                positions[index * 3 + 2] = orb.textPosition[2];
            });

            gl.uniform3fv(textPositionsLoc, positions);
            gl.uniform1i(textCountLoc, orbs.length);
            
            // For now, just use the first orb's texture
            if (orbs.length > 0) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, orbs[0].textTexture);
                gl.uniform1i(textTextureLoc, 2);
            }
        }

        function render() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            try {
                resizeCanvas();

                // Update stream time
                const elapsed = Date.now() - streamStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.querySelector('.stream-time').textContent = timeString;

                const timeLocation = gl.getUniformLocation(program, 'iTime');
                const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
                const mouseLocation = gl.getUniformLocation(program, 'iMouse');

                const time = (Date.now() - startTime) / 1000;
                gl.uniform1f(timeLocation, time);
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform2f(mouseLocation, mouseX, 0);

                updateOrbUniforms();
                updateTextUniforms();

                if (video.readyState >= video.HAVE_CURRENT_DATA) {
    gl.activeTexture(gl.TEXTURE1);  // Bind to texture unit 1
    gl.bindTexture(gl.TEXTURE_2D, videoTexture);
    gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        video
    );
}
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                requestAnimationFrame(render);
            } catch (error) {
                console.error('Render error:', error);
            }
        }

        window.onload = initGL;
        window.onmousemove = (e) => {
            mouseX = e.clientX;
        };

        // Keyboard controls for camera movement
        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case 'q': keys.q = true; break;
                case 'e': keys.e = true; break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case 'q': keys.q = false; break;
                case 'e': keys.e = false; break;
            }
        });

        function updateCameraMovement() {
            const rotation = mouseX * 0.0075 + 0.025;
            const cosRot = Math.cos(rotation);
            const sinRot = Math.sin(rotation);
            
            // Calculate movement vectors based on camera rotation
            const forward = { x: sinRot, z: cosRot };
            const right = { x: cosRot, z: -sinRot };
            
            if (keys.w) {
                cameraPosition.x += forward.x * moveSpeed;
                cameraPosition.z += forward.z * moveSpeed;
            }
            if (keys.s) {
                cameraPosition.x -= forward.x * moveSpeed;
                cameraPosition.z -= forward.z * moveSpeed;
            }
            if (keys.a) {
                cameraPosition.x -= right.x * moveSpeed;
                cameraPosition.z -= right.z * moveSpeed;
            }
            if (keys.d) {
                cameraPosition.x += right.x * moveSpeed;
                cameraPosition.z += right.z * moveSpeed;
            }
            if (keys.q) {
                cameraPosition.y -= moveSpeed;
            }
            if (keys.e) {
                cameraPosition.y += moveSpeed;
            }
        }
    </script>
</body>
</html>