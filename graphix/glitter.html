<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tandy Nitespace</title>
    <link rel="stylesheet" href="./indexNew.css">
    <link rel="stylesheet" href="./chat.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

</head>

<body>

    <!-- <img src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/1231630/moon2.png" alt=""> -->
    <div class="stars"></div>
    <!-- <div class="twinkling"></div> -->
    <!-- <div class="clouds"></div> -->

    <header>
        <span className="text-red-500" style="color: red;">T</span>
        <span className="text-yellow-500" style="color: yellow;">A</span>
        <span className="text-blue-500" style="color: blue;">N</span>
        <span className="text-purple-500" style="color: purple;">D</span>
        <span className="text-green-500" style="color: green;">Y</span>
        Nitespace
    </header>
    <div class="app-grid">
        <div class="pretend-app">
            Tandylinx
            <!-- <img src="./catalog.gif"> -->
        </div>

        <div class="pretend-app">
            tandy forum
        </div>
        <div class="pretend-app">
            tandy chat
        </div>
        <div class="pretend-app">
            SounClown
        </div>
        <div class="pretend-app">
            digiCDs
        </div>
        <!-- <a href="./box.html">

            <div class="pretend-app" style="background-image:url(./cube.png); background-size: cover;">
            </div>
        </a> -->
        <div class="pretend-app">
            timelocked thing
        </div>
        <div class="pretend-app">
            fake tile shader
        </div>
        <div class="pretend-app">
            weird shader
        </div>
        <div class="pretend-app">
            weird error page
        </div>
        <div class="pretend-app">
            tandynet
        </div>
    </div>

    <div id="chat-container">
        <div id="chat-julie" class="chatbox">
            <div class="chatbox-header">
                <h3>Julie</h3>
            </div>
            <div class="chatbox-content">
                <div class="chatbox-message">
                    <span class="chatbox-message__sender">Julie:</span>
                    <span class="chatbox-message__content">Hey, how are you?</span>
                </div>
                <div class="chatbox-message">
                    <span class="chatbox-message__sender">You:</span>
                    <span class="chatbox-message__content">I'm good, thanks! How about you?</span>
                </div>
                <div class="chatbox-message">
                    <span class="chatbox-message__sender">Julie:</span>
                    <span class="chatbox-message__content">I'm doing great, thanks for asking!</span>
                </div>
            </div>
            <div class="chatbox-footer">
                <input type="text" placeholder="Type a message...">
                <button>Send</button>
            </div>
        </div>
    </div>

    <div id="user-list-container" class="">
        <button id="toggle-button">Hide Online Users</button>
        <div id="user-list-content">
            <h3>Online Users</h3>
            <ul id="online-users">
                <!-- Online users will be injected here -->
            </ul>
            <h4>Recently Online Users</h4>
            <ul id="recent-users">
                <!-- Recently online users will be injected here -->
            </ul>
        </div>
    </div>

<
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const toggleButton = document.getElementById('toggle-button');
            const container = document.getElementById('user-list-container');

            // Dummy data for users
            const onlineUsers = ['jestereliceX', 'passwordtest', 'umru'];
            const recentUsers = ['Dave (2 min ago)', 'Eve (10 min ago)', 'Frank (30 min ago)'];

            // Populate the online users list
            const onlineUsersList = document.getElementById('online-users');
            onlineUsers.forEach(user => {
                const li = document.createElement('li');
                const dot = document.createElement('span');
                dot.classList.add('dot', 'green');

                const username = document.createElement('span');
                username.textContent = user;
                li.appendChild(dot);
                li.appendChild(username);
                onlineUsersList.appendChild(li);
            });

            // Populate the recently online users list
            const recentUsersList = document.getElementById('recent-users');
            recentUsers.forEach(user => {
                const li = document.createElement('li');
                // const statusDot = document.createElement('i');
                // statusDot.classList.add('pulse');
                // statusDot.classList.add('green');

                // li.appendChild(document.createElement('i'));;
                const dot = document.createElement('span');
                dot.classList.add('dot');

                const username = document.createElement('span');
                username.textContent = user;
                li.appendChild(dot);
                li.appendChild(username);

                recentUsersList.appendChild(li);
            });

            // Toggle visibility of the user list
            toggleButton.addEventListener('click', () => {
                if (container.classList.contains('collapsed')) {
                    container.classList.remove('collapsed');
                    toggleButton.textContent = 'Hide Online Users';
                } else {
                    container.classList.add('collapsed');
                    toggleButton.textContent = 'Show Online Users';
                }
            });
        });
    </script>>
<script>
    const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 1);
document.body.appendChild(renderer.domElement);

class GlitterSystem {
    constructor() {
        this.flakes = [];
        this.flakeGeometry = new THREE.PlaneGeometry(0.03, 0.03);
        
        const createMetallicMaterial = (color, specialColor) => {
            return new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 1.0,
                roughness: 0.2,
                reflectivity: 1.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                side: THREE.DoubleSide,
                specularIntensity: 1.0,
                specularColor: specialColor,
                emissive: color,
                emissiveIntensity: 0.2
            });
        };

        this.materials = [
            createMetallicMaterial(0xCCCCCC, 0xFFFFFF), // Silver
            createMetallicMaterial(0xFFD700, 0xFFCC00), // Gold
            createMetallicMaterial(0xFF69B4, 0xFF00FF), // Holographic Pink
            createMetallicMaterial(0x4169E1, 0x00FFFF), // Holographic Blue
            createMetallicMaterial(0xFFFFFF, 0xFF00FF), // Rainbow Pearl
            createMetallicMaterial(0xB87333, 0xFFA500)  // Copper
        ];
    }

    emit(position, count) {
        for (let i = 0; i < count; i++) {
            const material = this.materials[Math.floor(Math.random() * this.materials.length)].clone();
            const flake = new THREE.Mesh(this.flakeGeometry, material);
            
            const scale = 0.8 + Math.random() * 0.5;
            flake.scale.set(scale, scale, scale);
            
            flake.position.copy(position).add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
            ));
            
            flake.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );
            
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.01 + Math.random() * 0.03;
            
            const flakeData = {
                mesh: flake,
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    (Math.random() - 0.5) * 0.05
                ),
                rotationVelocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.15
                ),
                life: 1.0,
                initialScale: scale
            };
            
            scene.add(flake);
            this.flakes.push(flakeData);
        }
    }

    update() {
        for (let i = this.flakes.length - 1; i >= 0; i--) {
            const flake = this.flakes[i];
            
            flake.mesh.position.add(flake.velocity);
            
            flake.velocity.y -= 0.0005; // Gravity
            flake.velocity.multiplyScalar(0.98); // Air resistance
            
            flake.mesh.rotation.x += flake.rotationVelocity.x;
            flake.mesh.rotation.y += flake.rotationVelocity.y;
            flake.mesh.rotation.z += flake.rotationVelocity.z;
            
            flake.life -= 0.008;
            
            if (flake.life <= 0) {
                scene.remove(flake.mesh);
                this.flakes.splice(i, 1);
            } else {
                flake.mesh.material.opacity = flake.life;
                const scale = flake.initialScale * flake.life;
                flake.mesh.scale.set(scale, scale, scale);
            }
        }
    }
}

// Create interactive plane
const planeGeometry = new THREE.PlaneGeometry(5, 4, 200, 200);
const planeMaterial = new THREE.MeshPhongMaterial({
    color: 0x100010,
    specular: 0x444444,
    shininess: 30,
    flatShading: false,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 1.0
});

const plane = new THREE.Mesh(planeGeometry, planeMaterial);
scene.add(plane);

// Enhanced lighting setup
const mainLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
mainLight.position.set(5, 5, 7);
scene.add(mainLight);

const fillLight = new THREE.DirectionalLight(0x9090FF, 0.8);
fillLight.position.set(-5, -2, 3);
scene.add(fillLight);

const rimLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
rimLight.position.set(0, 5, -5);
scene.add(rimLight);

const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
scene.add(ambientLight);

// Add point lights for sparkles
const addSparkleLight = (x, y, z, color) => {
    const light = new THREE.PointLight(color, 0.8, 4);
    light.position.set(x, y, z);
    scene.add(light);
    return light;
};

const sparkleLight1 = addSparkleLight(2, 2, 2, 0xFFFFFF);
const sparkleLight2 = addSparkleLight(-2, -2, 2, 0xFFFFFF);
const sparkleLight3 = addSparkleLight(0, 2, -2, 0xFFFFFF);

camera.position.z = 2;

// Physics simulation variables
const originalPositions = planeGeometry.attributes.position.array.slice();
const velocities = new Float32Array(planeGeometry.attributes.position.array.length);
const forces = new Float32Array(planeGeometry.attributes.position.array.length);
let mousePosition = new THREE.Vector2();
let raycaster = new THREE.Raycaster();
let intersectionPoint = new THREE.Vector3();
let dragRadius = 0.4;

// Initialize glitter system
const glitterSystem = new GlitterSystem();

// Physics constants
const SPRING_CONSTANT = 0.1;
const DAMPING = 0.97;
const MASS = 20.90;
const FORCE_MULTIPLIER = 0.15;

// Create normal buffer
const normalBuffer = new THREE.BufferAttribute(
    new Float32Array(planeGeometry.attributes.normal.array.length),
    3
);

function updateMousePosition(event) {
    mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
    mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

document.addEventListener('mousemove', updateMousePosition);
document.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    updateMousePosition({
        clientX: touch.clientX,
        clientY: touch.clientY
    });
}, { passive: true });

function computeCustomNormals() {
    const positions = planeGeometry.attributes.position.array;
    const normals = normalBuffer.array;
    const indices = planeGeometry.index.array;
    
    normals.fill(0);
    
    for (let i = 0; i < indices.length; i += 3) {
        const idx1 = indices[i] * 3;
        const idx2 = indices[i + 1] * 3;
        const idx3 = indices[i + 2] * 3;
        
        const v1 = new THREE.Vector3(
            positions[idx1],
            positions[idx1 + 1],
            positions[idx1 + 2]
        );
        const v2 = new THREE.Vector3(
            positions[idx2],
            positions[idx2 + 1],
            positions[idx2 + 2]
        );
        const v3 = new THREE.Vector3(
            positions[idx3],
            positions[idx3 + 1],
            positions[idx3 + 2]
        );
        
        const edge1 = v2.sub(v1);
        const edge2 = v3.sub(v1);
        const normal = edge1.cross(edge2).normalize();
        
        for (let j = 0; j < 3; j++) {
            const idx = indices[i + j] * 3;
            normals[idx] += normal.x;
            normals[idx + 1] += normal.y;
            normals[idx + 2] += normal.z;
        }
    }
    
    for (let i = 0; i < normals.length; i += 3) {
        const nx = normals[i];
        const ny = normals[i + 1];
        const nz = normals[i + 2];
        const length = Math.sqrt(nx * nx + ny * ny + nz * nz);
        
        if (length > 0) {
            normals[i] /= length;
            normals[i + 1] /= length;
            normals[i + 2] /= length;
        }
    }
    
    planeGeometry.attributes.normal.array.set(normals);
    planeGeometry.attributes.normal.needsUpdate = true;
}

function updatePhysics() {
    const positions = planeGeometry.attributes.position.array;
    forces.fill(0);

    raycaster.setFromCamera(mousePosition, camera);
    const intersection = raycaster.intersectObject(plane);
    
    if (intersection.length > 0) {
        intersectionPoint.copy(intersection[0].point);
        
        glitterSystem.emit(intersectionPoint, 50);
        
        // for (let i = 0; i < positions.length; i += 3) {
        //     const vertexPosition = new THREE.Vector3(
        //         positions[i],
        //         positions[i + 1],
        //         positions[i + 2]
        //     );
            
        //     const distance = vertexPosition.distanceTo(intersectionPoint);
            
        //     if (distance < dragRadius) {
        //         const force = 1 - (distance / dragRadius);
        //         const direction = vertexPosition.sub(intersectionPoint).normalize();
        //         forces[i] += direction.x * force * FORCE_MULTIPLIER;
        //         forces[i + 1] += direction.y * force * FORCE_MULTIPLIER;
        //         forces[i + 2] += direction.z * force * FORCE_MULTIPLIER;
        //     }
        // }
    }

    for (let i = 0; i < positions.length; i += 3) {
        const dx = originalPositions[i] - positions[i];
        const dy = originalPositions[i + 1] - positions[i + 1];
        const dz = originalPositions[i + 2] - positions[i + 2];
        
        forces[i] += dx * SPRING_CONSTANT;
        forces[i + 1] += dy * SPRING_CONSTANT;
        forces[i + 2] += dz * SPRING_CONSTANT;
        
        velocities[i] = velocities[i] * DAMPING + forces[i] / MASS;
        velocities[i + 1] = velocities[i + 1] * DAMPING + forces[i + 1] / MASS;
        velocities[i + 2] = velocities[i + 2] * DAMPING + forces[i + 2] / MASS;
        
        positions[i] += velocities[i];
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2];
    }

    planeGeometry.attributes.position.needsUpdate = true;
    computeCustomNormals();
}

function updateSparkles(time) {
    const radius = 3;
    sparkleLight1.position.x = Math.sin(time * 0.001) * radius;
    sparkleLight1.position.y = Math.cos(time * 0.001) * radius;
    
    sparkleLight2.position.x = Math.sin(time * 0.0015 + 2) * radius;
    sparkleLight2.position.y = Math.cos(time * 0.0015 + 2) * radius;
    
    sparkleLight3.position.x = Math.sin(time * 0.002 + 4) * radius;
    sparkleLight3.position.y = Math.cos(time * 0.002 + 4) * radius;
}

function animate(time) {
    requestAnimationFrame(animate);
    updatePhysics();
    glitterSystem.update();
    updateSparkles(time);
    renderer.render(scene, camera);
}

function onWindowResize() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const distance = camera.position.z;
    const vFov = camera.fov * Math.PI / 180;
    const height = 2 * Math.tan(vFov / 2) * distance;
    const width = height * aspect;
    
    plane.scale.set(width / 4 * 1.2, height / 3 * 1.2, 1);
}

window.addEventListener('resize', onWindowResize);
onWindowResize();
animate(0);
</script>
</body>

</html>
</script>
</body>

</html>
